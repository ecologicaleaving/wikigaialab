/**
 * User ID Unification Migration
 * 
 * This migration safely migrates existing user data to use deterministic UUIDs
 * generated by the UserIdentityService, ensuring data integrity and consistency.
 * 
 * Features:
 * - Identifies users with inconsistent IDs
 * - Creates ID mapping table for migration tracking
 * - Atomic migration of foreign key references
 * - Validation of data integrity post-migration
 * - Rollback capability
 */

import { createClient } from '@supabase/supabase-js';
import type { Database } from '@wikigaialab/database';
import { getUserIdentityService } from '@/lib/auth/UserIdentityService';
import { logger } from '@/lib/debug/logger';

// Helper function to generate deterministic user ID
function generateUserIdFromEmail(email: string): string {
  const service = getUserIdentityService();
  return service.generateDeterministicUserId(email);
}

// Migration configuration
interface MigrationConfig {
  dryRun: boolean;
  batchSize: number;
  skipValidation: boolean;
}

// Migration result tracking
interface MigrationResult {
  success: boolean;
  usersProcessed: number;
  usersUpdated: number;
  foreignKeyReferencesUpdated: number;
  errors: Array<{
    userId: string;
    email: string;
    error: string;
    timestamp: string;
  }>;
  duration: number;
  correlationId: string;
}

// User ID mapping for tracking changes
interface UserIdMapping {
  old_id: string;
  new_id: string;
  email: string;
  migrated_at: string;
  status: 'pending' | 'completed' | 'failed' | 'rolled_back';
}

/**
 * User ID Unification Migration Class
 */
export class UserIdUnificationMigration {
  private supabase: ReturnType<typeof createClient<Database>>;
  private correlationId: string;
  private config: MigrationConfig;

  constructor(config: Partial<MigrationConfig> = {}) {
    this.correlationId = `migration_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    this.config = {
      dryRun: config.dryRun ?? true,
      batchSize: config.batchSize ?? 100,
      skipValidation: config.skipValidation ?? false
    };
    this.supabase = this.initializeSupabaseClient();
  }

  /**
   * Initialize Supabase client with service key
   */
  private initializeSupabaseClient() {
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
    const supabaseKey = process.env.SUPABASE_SERVICE_KEY;
    
    if (!supabaseUrl || !supabaseKey) {
      throw new Error('Missing Supabase environment variables for migration');
    }
    
    return createClient<Database>(supabaseUrl, supabaseKey);
  }

  /**
   * Create migration tracking table
   */
  private async createMigrationTable(): Promise<void> {
    const createTableSQL = `
      CREATE TABLE IF NOT EXISTS user_id_migration_log (
        id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
        old_id TEXT NOT NULL,
        new_id UUID NOT NULL,
        email TEXT NOT NULL,
        migrated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
        status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'completed', 'failed', 'rolled_back')),
        error_message TEXT,
        correlation_id TEXT NOT NULL,
        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
        updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
      );
      
      CREATE INDEX IF NOT EXISTS idx_user_id_migration_old_id ON user_id_migration_log(old_id);
      CREATE INDEX IF NOT EXISTS idx_user_id_migration_new_id ON user_id_migration_log(new_id);
      CREATE INDEX IF NOT EXISTS idx_user_id_migration_email ON user_id_migration_log(email);
      CREATE INDEX IF NOT EXISTS idx_user_id_migration_status ON user_id_migration_log(status);
    `;

    const { error } = await this.supabase.rpc('exec_sql', { sql: createTableSQL });
    if (error) {
      throw new Error(`Failed to create migration table: ${error.message}`);
    }

    logger.info('Migration tracking table created', { 
      correlationId: this.correlationId 
    });
  }

  /**
   * Analyze existing users to identify inconsistencies
   */
  async analyzeUsers(): Promise<{
    totalUsers: number;
    usersWithInconsistentIds: Array<{
      current_id: string;
      email: string;
      deterministic_id: string;
      needs_migration: boolean;
    }>;
    duplicateEmails: Array<{
      email: string;
      user_ids: string[];
    }>;
  }> {
    logger.info('Starting user analysis', { 
      correlationId: this.correlationId 
    });

    // Get all users
    const { data: users, error } = await this.supabase
      .from('users')
      .select('id, email, name, created_at')
      .order('created_at', { ascending: true });

    if (error) {
      throw new Error(`Failed to fetch users: ${error.message}`);
    }

    const totalUsers = users?.length || 0;
    const usersWithInconsistentIds: Array<{
      current_id: string;
      email: string;
      deterministic_id: string;
      needs_migration: boolean;
    }> = [];

    const emailCounts: Record<string, string[]> = {};

    // Analyze each user
    for (const user of users || []) {
      if (!user.email) continue;

      // Track email duplicates
      if (!emailCounts[user.email]) {
        emailCounts[user.email] = [];
      }
      emailCounts[user.email].push(user.id);

      // Check if current ID matches deterministic ID
      const deterministicId = generateUserIdFromEmail(user.email);
      const needsMigration = user.id !== deterministicId;

      if (needsMigration) {
        usersWithInconsistentIds.push({
          current_id: user.id,
          email: user.email,
          deterministic_id: deterministicId,
          needs_migration: true
        });
      }
    }

    // Find duplicate emails
    const duplicateEmails = Object.entries(emailCounts)
      .filter(([_, ids]) => ids.length > 1)
      .map(([email, user_ids]) => ({ email, user_ids }));

    logger.info('User analysis completed', {
      correlationId: this.correlationId,
      totalUsers,
      usersNeedingMigration: usersWithInconsistentIds.length,
      duplicateEmails: duplicateEmails.length
    });

    return {
      totalUsers,
      usersWithInconsistentIds,
      duplicateEmails
    };
  }

  /**
   * Execute the migration
   */
  async executeMigration(): Promise<MigrationResult> {
    const startTime = Date.now();
    const result: MigrationResult = {
      success: false,
      usersProcessed: 0,
      usersUpdated: 0,
      foreignKeyReferencesUpdated: 0,
      errors: [],
      duration: 0,
      correlationId: this.correlationId
    };

    try {
      logger.info('Starting user ID unification migration', {
        correlationId: this.correlationId,
        config: this.config
      });

      // Create migration tracking table
      await this.createMigrationTable();

      // Analyze users first
      const analysis = await this.analyzeUsers();
      
      if (analysis.duplicateEmails.length > 0) {
        throw new Error(`Cannot proceed: Found ${analysis.duplicateEmails.length} duplicate emails that must be resolved first`);
      }

      if (analysis.usersWithInconsistentIds.length === 0) {
        logger.info('No users need migration', { correlationId: this.correlationId });
        result.success = true;
        return result;
      }

      // Process users in batches
      const batches = this.createBatches(analysis.usersWithInconsistentIds, this.config.batchSize);
      
      for (let i = 0; i < batches.length; i++) {
        const batch = batches[i];
        logger.info(`Processing batch ${i + 1} of ${batches.length}`, {
          correlationId: this.correlationId,
          batchSize: batch.length
        });

        for (const userToMigrate of batch) {
          try {
            await this.migrateUser(userToMigrate);
            result.usersUpdated++;
          } catch (error) {
            result.errors.push({
              userId: userToMigrate.current_id,
              email: userToMigrate.email,
              error: error instanceof Error ? error.message : 'Unknown error',
              timestamp: new Date().toISOString()
            });
          }
          result.usersProcessed++;
        }
      }

      // Validate migration if not skipped
      if (!this.config.skipValidation) {
        await this.validateMigration();
      }

      result.success = result.errors.length === 0;
      result.duration = Date.now() - startTime;

      logger.info('Migration completed', {
        correlationId: this.correlationId,
        result: {
          success: result.success,
          usersProcessed: result.usersProcessed,
          usersUpdated: result.usersUpdated,
          errorCount: result.errors.length,
          duration: result.duration
        }
      });

      return result;

    } catch (error) {
      result.duration = Date.now() - startTime;
      result.errors.push({
        userId: 'migration',
        email: 'system',
        error: error instanceof Error ? error.message : 'Unknown migration error',
        timestamp: new Date().toISOString()
      });

      logger.error('Migration failed', error, {
        correlationId: this.correlationId,
        result
      });

      return result;
    }
  }

  /**
   * Migrate a single user with atomic operations
   */
  private async migrateUser(userToMigrate: {
    current_id: string;
    email: string;
    deterministic_id: string;
    needs_migration: boolean;
  }): Promise<void> {
    const { current_id, email, deterministic_id } = userToMigrate;

    logger.info('Migrating user', {
      correlationId: this.correlationId,
      currentId: current_id,
      email,
      deterministicId: deterministic_id
    });

    if (this.config.dryRun) {
      logger.info('DRY RUN: Would migrate user', {
        correlationId: this.correlationId,
        currentId: current_id,
        deterministicId: deterministic_id
      });
      return;
    }

    // Log migration attempt
    const { data: migrationLog, error: logError } = await this.supabase
      .from('user_id_migration_log')
      .insert({
        old_id: current_id,
        new_id: deterministic_id,
        email: email,
        status: 'pending',
        correlation_id: this.correlationId
      })
      .select('id')
      .single();

    if (logError) {
      throw new Error(`Failed to log migration attempt: ${logError.message}`);
    }

    try {
      // Execute migration in transaction using stored procedure
      const { data, error } = await this.supabase.rpc('migrate_user_id', {
        old_user_id: current_id,
        new_user_id: deterministic_id,
        user_email: email
      });

      if (error) {
        throw new Error(`Migration procedure failed: ${error.message}`);
      }

      // Update migration log to completed
      await this.supabase
        .from('user_id_migration_log')
        .update({
          status: 'completed',
          updated_at: new Date().toISOString()
        })
        .eq('id', migrationLog.id);

      logger.info('User migration completed', {
        correlationId: this.correlationId,
        currentId: current_id,
        deterministicId: deterministic_id,
        email
      });

    } catch (error) {
      // Update migration log to failed
      await this.supabase
        .from('user_id_migration_log')
        .update({
          status: 'failed',
          error_message: error instanceof Error ? error.message : 'Unknown error',
          updated_at: new Date().toISOString()
        })
        .eq('id', migrationLog.id);

      throw error;
    }
  }

  /**
   * Create batches for processing
   */
  private createBatches<T>(items: T[], batchSize: number): T[][] {
    const batches: T[][] = [];
    for (let i = 0; i < items.length; i += batchSize) {
      batches.push(items.slice(i, i + batchSize));
    }
    return batches;
  }

  /**
   * Validate migration results
   */
  private async validateMigration(): Promise<void> {
    logger.info('Validating migration results', {
      correlationId: this.correlationId
    });

    // Check for users with non-deterministic IDs
    const { data: users, error } = await this.supabase
      .from('users')
      .select('id, email');

    if (error) {
      throw new Error(`Validation failed: ${error.message}`);
    }

    for (const user of users || []) {
      if (!user.email) continue;
      
      const expectedId = generateUserIdFromEmail(user.email);
      if (user.id !== expectedId) {
        throw new Error(`Validation failed: User ${user.email} has ID ${user.id} but expected ${expectedId}`);
      }
    }

    // Check for foreign key constraint violations
    const { data: problems, error: problemsError } = await this.supabase
      .from('problems')
      .select('id, proposer_id')
      .limit(100);

    if (problemsError) {
      throw new Error(`Foreign key validation failed: ${problemsError.message}`);
    }

    logger.info('Migration validation completed successfully', {
      correlationId: this.correlationId,
      usersValidated: users?.length || 0,
      problemsChecked: problems?.length || 0
    });
  }

  /**
   * Rollback migration for a specific user
   */
  async rollbackUser(email: string): Promise<void> {
    logger.info('Rolling back user migration', {
      correlationId: this.correlationId,
      email
    });

    // Get migration log
    const { data: migrationLog, error } = await this.supabase
      .from('user_id_migration_log')
      .select('*')
      .eq('email', email)
      .eq('status', 'completed')
      .order('migrated_at', { ascending: false })
      .limit(1)
      .single();

    if (error || !migrationLog) {
      throw new Error(`No completed migration found for user: ${email}`);
    }

    if (this.config.dryRun) {
      logger.info('DRY RUN: Would rollback user', {
        correlationId: this.correlationId,
        email,
        newId: migrationLog.new_id,
        oldId: migrationLog.old_id
      });
      return;
    }

    // Execute rollback
    const { error: rollbackError } = await this.supabase.rpc('migrate_user_id', {
      old_user_id: migrationLog.new_id,
      new_user_id: migrationLog.old_id,
      user_email: email
    });

    if (rollbackError) {
      throw new Error(`Rollback failed: ${rollbackError.message}`);
    }

    // Update migration log
    await this.supabase
      .from('user_id_migration_log')
      .update({
        status: 'rolled_back',
        updated_at: new Date().toISOString()
      })
      .eq('id', migrationLog.id);

    logger.info('User rollback completed', {
      correlationId: this.correlationId,
      email
    });
  }
}

/**
 * Factory function to create migration instance
 */
export function createUserIdMigration(config?: Partial<MigrationConfig>): UserIdUnificationMigration {
  return new UserIdUnificationMigration(config);
}

/**
 * Utility function for quick analysis
 */
export async function analyzeUserIdConsistency(): Promise<{
  totalUsers: number;
  consistentUsers: number;
  inconsistentUsers: number;
  duplicateEmails: number;
}> {
  const migration = createUserIdMigration({ dryRun: true });
  const analysis = await migration.analyzeUsers();
  
  return {
    totalUsers: analysis.totalUsers,
    consistentUsers: analysis.totalUsers - analysis.usersWithInconsistentIds.length,
    inconsistentUsers: analysis.usersWithInconsistentIds.length,
    duplicateEmails: analysis.duplicateEmails.length
  };
}